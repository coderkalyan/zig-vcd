const std = @import("std");
const testing = std.testing;
const Allocator = std.mem.Allocator;

const Keyword = enum {
    // comment
    comment,
    // general header information
    date,
    version,
    timescale,
    // variable declaration and scoping
    @"var",
    scope,
    upscope,
    // header delimiter
    enddefinitions,
    // value dump control flow
    dumpall,
    dumpon,
    dumpoff,
    dumpvars,
};

/// Represents a toplevel VCD file that has been parsed. All string slices
/// are pointers into the original source file and no copies are made.
pub const ValueChangeDump = struct {
    /// Source file data being parsed. This slice is not owned.
    source: [:0]const u8,
    /// File timestamp string. Slice into the source buffer.
    date: ?[]const u8,
    /// Simulator name and version. Slice into the source buffer.
    version: ?[]const u8,
    /// Timescale of the simulation.
    timescale: ?Timescale,
    /// Internal string bytes that own copies of all identifiers
    /// referenced in the vcd data. This is not used directly but
    /// through span() from a variable or signal key.
    bytes: []const u8,
    /// Single "tape" representing the variable hierarchy as seen
    /// directly in the change dump file. This is not a full tree
    /// but can be used to build one by iterating in order.
    hierarchy: []const Node,
    /// List of variables and their corresponding time series data.
    signals: []const Signal,

    pub const Timescale = struct {
        /// Number of time units.
        number: Number,
        /// Base time unit, used to interpret the number.
        unit: Unit,

        pub const Number = enum(u8) {
            one,
            ten,
            hundred,
        };

        pub const Unit = enum(u8) {
            second,
            milli,
            micro,
            nano,
            pico,
            femto,
        };
    };

    pub const Node = struct {
        tag: Tag,
        payload: Payload,

        pub const Tag = enum(u8) {
            // scopes (non-leaf nodes)
            module,
            task,
            function,
            begin,
            fork,
            // ends a previously started scope
            upscope,

            // variables (leaf nodes)
            event,
            integer,
            parameter,
            real,
            realtime,
            reg,
            supply0,
            supply1,
            time,
            tri,
            triand,
            trior,
            trireg,
            tri0,
            tri1,
            wand,
            wire,
            wor,
        };

        pub const Payload = union {
            /// Empty payload, used for tags that don't have any additional data.
            placeholder: void,
            /// Scope information, used for tags that define scopes.
            scope: Scope,
            /// Variable information, used for tags that define variables.
            @"var": Var,

            pub const Scope = struct {
                /// Original name of the scope in the source language. This is an index
                /// into the bytes table. To retrieve the original string, use span().
                name: u32,
            };

            pub const Var = struct {
                /// Index into the signals table that contains variable metadata
                /// and time series data. Name isn't directly included here to
                /// avoid duplication.
                signal: u32,
            };
        };

        // scopes
        pub const scope_map = std.StaticStringMap(Tag).initComptime(.{
            .{ "module", .module },
            .{ "task", .task },
            .{ "function", .function },
            .{ "begin", .begin },
            .{ "fork", .fork },
        });

        // variables
        pub const variable_map = std.StaticStringMap(Tag).initComptime(.{
            .{ "event", .event },
            .{ "integer", .integer },
            .{ "parameter", .parameter },
            .{ "real", .real },
            .{ "realtime", .realtime },
            .{ "reg", .reg },
            .{ "supply0", .supply0 },
            .{ "supply1", .supply1 },
            .{ "time", .time },
            .{ "tri", .tri },
            .{ "triand", .triand },
            .{ "trior", .trior },
            .{ "trireg", .trireg },
            .{ "tri0", .tri0 },
            .{ "tri1", .tri1 },
            .{ "wand", .wand },
            .{ "wire", .wire },
            .{ "wor", .wor },
        });
    };

    pub const Signal = struct {
        /// Shape (number and range of bits) present in the variable.
        shape: Shape,
        /// Identifier code of the variable. This is a short, uniquestring identifer
        /// that is used to reference the variable and is generated by the simulator.
        /// It is not generally human-readable. This is an index into the bytes table.
        /// To retrieve the original string, use span().
        code: u32,
        /// Original variable name of the variable in the source language. This is an index
        /// into the bytes table. To retrieve the original string, use span().
        name: u32,
        /// Time series changes for the variable. The data is stored as one byte per bit,
        /// and therefore the stride is the width of the vector.
        waves: []const u8,
        /// Timestamps for the variable, corresponding to each time series sample.
        times: []const u64,

        pub const Shape = union(enum) {
            /// The variable is a scalar without any index provided.
            scalar: void,
            /// The variable is a scalar with a index provided.
            offset: u32,
            /// The variable is a vector provided as a range.
            range: struct { start: u32, end: u32 },

            pub fn width(self: Shape) u32 {
                return switch (self) {
                    .scalar, .offset => 1,
                    .range => |range| return @abs(range.start - range.end) + 1,
                };
            }
        };
    };

    pub fn deinit(self: *const ValueChangeDump, allocator: Allocator) void {
        allocator.free(self.bytes);
        allocator.free(self.hierarchy);
        for (self.signals) |*signal| {
            allocator.free(signal.waves);
            allocator.free(signal.times);
        }
        allocator.free(self.signals);
    }
};

const IndexContext = struct {
    bytes: *std.ArrayListUnmanaged(u8),

    pub fn eql(_: IndexContext, a: u32, b: u32) bool {
        return a == b;
    }

    pub fn hash(self: IndexContext, x: u32) u64 {
        const ptr: [*:0]const u8 = @ptrCast(&self.bytes.items[x]);
        const str = std.mem.span(ptr);
        return std.hash_map.hashString(str);
    }
};

const SliceAdapter = struct {
    bytes: []const u8,

    pub fn eql(self: SliceAdapter, a_str: []const u8, b: u32) bool {
        const ptr: [*:0]const u8 = @ptrCast(&self.bytes[b]);
        const b_str = std.mem.span(ptr);
        return std.mem.eql(u8, a_str, b_str);
    }

    pub fn hash(_: SliceAdapter, str: []const u8) u64 {
        return std.hash_map.hashString(str);
    }
};

const State = enum {
    // these two parent states are the "resting" states
    // for each new line in the parser. the destinction
    // between header and body allows a more strict parser
    // that rejects unexpected declarations in the body
    // and unexpected value changes in the header.
    header,
    body,

    // these function similar to body, but are used to track
    // nested declaration blocks that include values
    dumpall,
    dumpon,
    dumpoff,
    dumpvars,

    // consumes an $end keyword and then transitions to the
    // respective parent state
    end_header,
    end_body,
    // discards a comment and then transitions to the respective
    // parent state
    comment_header,
    comment_body,

    // states for parsing keyword declarations
    end,
    date,
    version,
    timescale,
    scope,
    @"var",
    upscope,
    enddefinitions,

    const header_map = std.StaticStringMap(State).initComptime(.{
        .{ "comment", .comment_header },
        .{ "date", .date },
        .{ "version", .version },
        .{ "timescale", .timescale },
        .{ "var", .@"var" },
        .{ "scope", .scope },
        .{ "upscope", .upscope },
        .{ "enddefinitions", .enddefinitions },
    });

    const body_map = std.StaticStringMap(State).initComptime(.{
        .{ "comment", .comment_body },
        .{ "dumpall", .dumpall },
        .{ "dumpon", .dumpon },
        .{ "dumpoff", .dumpoff },
        .{ "dumpvars", .dumpvars },
    });
};

pub fn parse(allocator: Allocator, source: [:0]const u8) !ValueChangeDump {
    const Node = ValueChangeDump.Node;
    const Timescale = ValueChangeDump.Timescale;
    const Signal = ValueChangeDump.Signal;
    const Shape = Signal.Shape;

    // String intern pool that maps a unique string identifier to a source
    // string in bytes. This is used during parsing to deduplicate strings
    // and map strings to their canonical representation (using the IndexContext).
    // After parsing, only the string bytes are needed to return string data as
    // no new data is interned.
    var string_table: std.HashMapUnmanaged(u32, void, IndexContext, std.hash_map.default_max_load_percentage) = .empty;
    defer string_table.deinit(allocator);
    var bytes: std.ArrayListUnmanaged(u8) = .empty;
    errdefer bytes.deinit(allocator);

    var date: ?[]const u8 = null;
    var version: ?[]const u8 = null;
    var timescale: ?ValueChangeDump.Timescale = null;

    var nodes: std.ArrayListUnmanaged(Node) = .empty;
    errdefer nodes.deinit(allocator);

    var signals: std.ArrayListUnmanaged(struct {
        shape: Shape,
        code: u32,
        name: u32,
        waves: std.ArrayListUnmanaged(u8),
        times: std.ArrayListUnmanaged(u64),
    }) = .empty;
    defer {
        for (signals.items) |*signal| {
            signal.waves.deinit(allocator);
            signal.times.deinit(allocator);
        }
        signals.deinit(allocator);
    }

    var map: std.AutoHashMapUnmanaged(u32, u32) = .empty;
    defer map.deinit(allocator);
    var current_time: u64 = 0;

    var pos: usize = 0;
    fsm: switch (State.header) {
        .header => {
            // always expect a $ at the start of a line
            if (source[pos] != '$') return error.UnexpectedCharacter;
            pos += 1;

            // parse one keyword
            pos, const keyword = try eatToken(source, pos);
            pos = try skipWhitespace(source, pos);

            const next_state = State.header_map.get(keyword) orelse return error.UnknownKeyword;
            continue :fsm next_state;
        },
        .body => {
            switch (source[pos]) {
                // if a keyword is found, the process is similar to the header
                '$' => {
                    pos += 1;

                    // parse one keyword
                    pos, const keyword = try eatToken(source, pos);
                    pos = try skipWhitespace(source, pos);

                    const next_state = State.body_map.get(keyword) orelse return error.UnknownKeyword;
                    continue :fsm next_state;
                },
                // if a timestamp is found, parse and update the current time
                '#' => {
                    pos += 1;

                    pos, const str = try eatToken(source, pos);
                    const time = try std.fmt.parseInt(u32, str, 10);
                    current_time += time;

                    pos = skipWhitespace(source, pos) catch break :fsm;
                    continue :fsm .body;
                },
                // scalar value
                '0', '1', 'x', 'X', 'z', 'Z' => {
                    const bit = source[pos];
                    pos += 1;
                    pos, const code = try eatToken(source, pos);

                    const adapter: SliceAdapter = .{ .bytes = bytes.items };
                    const index = string_table.getKeyAdapted(code, adapter).?;

                    const signal_index = map.get(index) orelse return error.UnknownVariableCode;
                    const signal = &signals.items[signal_index];
                    std.debug.assert(signal.shape.width() == 1);
                    try signal.waves.append(allocator, bit);
                    try signal.times.append(allocator, current_time);

                    pos = skipWhitespace(source, pos) catch break :fsm;
                    continue :fsm .body;
                },
                // TODO: currently, only binary is allowed as a base
                // for multi-bit vectors. it isn't clear from the spec
                // which bases are allowed.
                'b' => {
                    pos += 1;

                    pos, const bits = try eatToken(source, pos);
                    pos = try skipWhitespace(source, pos);
                    pos, const code = try eatToken(source, pos);

                    const adapter: SliceAdapter = .{ .bytes = bytes.items };
                    const index = string_table.getKeyAdapted(code, adapter).?;

                    const signal_index = map.get(index) orelse return error.UnknownVariableCode;
                    const signal = &signals.items[signal_index];
                    try signal.waves.appendSlice(allocator, bits);
                    try signal.times.append(allocator, current_time);

                    pos = skipWhitespace(source, pos) catch break :fsm;
                    continue :fsm .body;
                },
                else => {
                    std.debug.print("unexpected: '{c}'\n", .{source[pos]});
                    return error.UnexpectedCharacter;
                },
            }
        },
        .dumpall => {
            // FIXME: implement this
            // try signals.ensureUnusedCapacity(allocator, 2);
            // signals.appendAssumeCapacity(@intCast(Marker.dumpall));
            //
            // length_index = signals.items.len;
            // signals.addOneAssumeCapacity();
            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);
            continue :fsm .end_body;
        },
        .dumpvars => {
            switch (source[pos]) {
                // if a keyword is found, the process is similar to the header
                // marks the end of the dumpvars block
                '$' => {
                    // TODO: validate that all instructions were seen
                    continue :fsm .end_body;
                },
                // scalar value
                '0', '1', 'x', 'X', 'z', 'Z' => {
                    const bit = source[pos];
                    pos += 1;
                    pos, const code = try eatToken(source, pos);
                    pos = try skipWhitespace(source, pos);

                    const adapter: SliceAdapter = .{ .bytes = bytes.items };
                    const index = string_table.getKeyAdapted(code, adapter).?;

                    const signal_index = map.get(index) orelse return error.UnknownVariableCode;
                    const signal = &signals.items[signal_index];
                    std.debug.assert(signal.shape.width() == 1);
                    try signal.waves.append(allocator, bit);
                    try signal.times.append(allocator, current_time);

                    continue :fsm .dumpvars;
                },
                // TODO: currently, only binary is allowed as a base
                // for multi-bit vectors. it isn't clear from the spec
                // which bases are allowed.
                'b' => {
                    pos += 1;

                    pos, const bits = try eatToken(source, pos);
                    pos = try skipWhitespace(source, pos);
                    pos, const code = try eatToken(source, pos);
                    pos = try skipWhitespace(source, pos);

                    const adapter: SliceAdapter = .{ .bytes = bytes.items };
                    const index = string_table.getKeyAdapted(code, adapter).?;

                    const signal_index = map.get(index) orelse return error.UnknownVariableCode;
                    const signal = &signals.items[signal_index];
                    try signal.waves.appendSlice(allocator, bits);
                    try signal.times.append(allocator, current_time);

                    continue :fsm .dumpvars;
                },
                else => {
                    std.debug.print("unexpected: '{c}'\n", .{source[pos]});
                    return error.UnexpectedCharacter;
                },
            }
        },
        inline .end_header, .end_body => |state| {
            std.debug.assert(source[pos] == '$');
            pos += 1;

            // parse one keyword
            const start = pos;
            pos = try seekWhitespace(source, pos);

            const keyword = source[start..pos];
            if (!std.mem.eql(u8, keyword, "end")) return error.UnexpectedKeyword;

            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);

            const next_state = if (state == .end_header) .header else .body;
            continue :fsm next_state;
        },
        .date => {
            // seek to $end token and capture the date string
            const start = pos;
            pos = try seek(source, pos, '$');

            date = std.mem.trim(u8, source[start..pos], &.{ ' ', '\t', '\r', '\n' });
            continue :fsm .end_header;
        },
        .version => {
            // seek to $end token and capture the version string
            const start = pos;
            pos = try seek(source, pos, '$');

            version = std.mem.trim(u8, source[start..pos], &.{ ' ', '\t', '\r', '\n' });
            continue :fsm .end_header;
        },
        .timescale => {
            pos = try skipWhitespace(source, pos);
            const number: Timescale.Number = num: {
                const start = pos;
                while (true) : (pos += 1) {
                    switch (source[pos]) {
                        0 => return error.ParseError,
                        '0'...'9' => continue,
                        else => break,
                    }
                }

                const str = source[start..pos];
                if (std.mem.eql(u8, str, "1")) break :num .one;
                if (std.mem.eql(u8, str, "10")) break :num .ten;
                if (std.mem.eql(u8, str, "100")) break :num .hundred;
                return error.UnexpectedTimescale;
            };

            pos = try skipWhitespace(source, pos);
            const unit: Timescale.Unit = unit: {
                const start = pos;
                while (true) : (pos += 1) {
                    switch (source[pos]) {
                        0 => return error.ParseError,
                        ' ', '\t', '\r', '\n' => break,
                        else => continue,
                    }
                }

                const str = source[start..pos];
                if (std.mem.eql(u8, str, "s")) break :unit .second;
                if (std.mem.eql(u8, str, "ms")) break :unit .milli;
                if (std.mem.eql(u8, str, "us")) break :unit .micro;
                if (std.mem.eql(u8, str, "ns")) break :unit .nano;
                if (std.mem.eql(u8, str, "ps")) break :unit .pico;
                if (std.mem.eql(u8, str, "fs")) break :unit .femto;
                return error.UnexpectedTimescale;
            };

            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);

            timescale = .{ .number = number, .unit = unit };
            continue :fsm .end_header;
        },
        .scope => {
            pos = try skipWhitespace(source, pos);
            const tag = tag: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const tag = Node.scope_map.get(str) orelse return error.UnknownTag;
                break :tag tag;
            };

            pos = try skipWhitespace(source, pos);
            const name = name: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const index: u32 = @intCast(bytes.items.len);
                const context: IndexContext = .{ .bytes = &bytes };
                try bytes.ensureUnusedCapacity(allocator, str.len + 1);
                bytes.appendSliceAssumeCapacity(str);
                bytes.appendAssumeCapacity(0);
                try string_table.putContext(allocator, index, {}, context);
                break :name index;
            };

            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);

            try nodes.append(allocator, .{
                .tag = tag,
                .payload = .{ .scope = .{ .name = name } },
            });
            continue :fsm .end_header;
        },
        .@"var" => {
            // $var <tag> <size> <code> <name> [range]
            pos = try skipWhitespace(source, pos);
            const tag = tag: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const tag = Node.variable_map.get(str) orelse return error.UnknownTag;
                break :tag tag;
            };

            pos = try skipWhitespace(source, pos);
            const size = size: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const size = try std.fmt.parseInt(u32, str, 10);
                break :size size;
            };

            pos = try skipWhitespace(source, pos);
            const code = code: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const index: u32 = @intCast(bytes.items.len);
                const context: IndexContext = .{ .bytes = &bytes };
                try bytes.ensureUnusedCapacity(allocator, str.len + 1);
                bytes.appendSliceAssumeCapacity(str);
                bytes.appendAssumeCapacity(0);
                try string_table.putContext(allocator, index, {}, context);
                break :code index;
            };

            pos = try skipWhitespace(source, pos);
            const name = name: {
                const start = pos;
                pos = try seekWhitespace(source, pos);
                const str = source[start..pos];

                const index: u32 = @intCast(bytes.items.len);
                const context: IndexContext = .{ .bytes = &bytes };
                try bytes.ensureUnusedCapacity(allocator, str.len + 1);
                bytes.appendSliceAssumeCapacity(str);
                bytes.appendAssumeCapacity(0);
                try string_table.putContext(allocator, index, {}, context);
                break :name index;
            };

            pos = try skipWhitespace(source, pos);
            const shape: Shape = switch (source[pos]) {
                '[' => shape: {
                    pos += 1;

                    // always expect a range start, which could be a range or offset
                    const range_start = range_start: {
                        const start = pos;
                        while (true) : (pos += 1) {
                            switch (source[pos]) {
                                0 => return error.ParseError,
                                '0'...'9' => continue,
                                else => break,
                            }
                        }

                        const str = source[start..pos];
                        const range_start = try std.fmt.parseInt(u32, str, 10);
                        break :range_start range_start;
                    };

                    switch (source[pos]) {
                        // optional range end, which marks this as a multi bit range
                        ':' => {
                            pos += 1;

                            const range_end = range_end: {
                                const start = pos;
                                while (true) : (pos += 1) {
                                    switch (source[pos]) {
                                        0 => return error.ParseError,
                                        '0'...'9' => continue,
                                        else => break,
                                    }
                                }

                                const str = source[start..pos];
                                const range_end = try std.fmt.parseInt(u32, str, 10);
                                break :range_end range_end;
                            };

                            if (source[pos] != ']') return error.UnexpectedCharacter;
                            pos += 1;

                            const delta = @abs(@as(i64, range_start) - @as(i64, range_end));
                            std.debug.assert((delta + 1) == size);
                            break :shape .{ .range = .{ .start = range_start, .end = range_end } };
                        },
                        ']' => {
                            pos += 1;
                            break :shape .{ .offset = range_start };
                        },
                        else => return error.UnexpectedCharacter,
                    }
                },
                '$' => .{ .scalar = {} },
                else => return error.UnexpectedCharacter,
            };

            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);

            const signal: u32 = @intCast(signals.items.len);
            try signals.append(allocator, .{
                .shape = shape,
                .code = code,
                .name = name,
                .waves = .empty,
                .times = .empty,
            });

            try map.put(allocator, code, signal);
            try nodes.append(allocator, .{
                .tag = tag,
                .payload = .{ .@"var" = .{ .signal = signal } },
            });
            continue :fsm .end_header;
        },
        .upscope => {
            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);

            try nodes.append(allocator, .{
                .tag = .upscope,
                .payload = .{ .placeholder = {} },
            });
            continue :fsm .end_header;
        },
        .enddefinitions => {
            // trim trailing whitespace
            pos = try skipWhitespace(source, pos);
            continue :fsm .end_body;
        },
        inline .comment_header, .comment_body => |state| {
            // discard comment value
            pos = try seek(source, pos, '$');

            const next_state = if (state == .comment_header) .end_header else .end_body;
            continue :fsm next_state;
        },
        else => |state| {
            std.debug.print("{}\n", .{state});
            unreachable;
        },
    }

    const out_signals = try allocator.alloc(Signal, signals.items.len);
    for (signals.items, 0..) |*signal, i| {
        out_signals[i] = .{
            .shape = signal.shape,
            .code = signal.code,
            .name = signal.name,
            .waves = try signal.waves.toOwnedSlice(allocator),
            .times = try signal.times.toOwnedSlice(allocator),
        };
    }

    return .{
        .source = source,
        .date = date,
        .version = version,
        .timescale = timescale,
        .bytes = try bytes.toOwnedSlice(allocator),
        .hierarchy = try nodes.toOwnedSlice(allocator),
        .signals = out_signals,
    };
}

fn seek(source: [:0]const u8, start: usize, comptime sentinel: u8) !usize {
    var pos = start;
    while (true) : (pos += 1) {
        switch (source[pos]) {
            0 => return error.ParseError,
            sentinel => break,
            else => continue,
        }
    }

    return pos;
}

fn seekWhitespace(source: [:0]const u8, start: usize) !usize {
    var pos = start;
    while (true) : (pos += 1) {
        switch (source[pos]) {
            0 => return error.ParseError,
            ' ', '\t', '\r', '\n' => break,
            else => continue,
        }
    }

    return pos;
}

fn skipWhitespace(source: [:0]const u8, start: usize) !usize {
    var pos = start;
    while (true) : (pos += 1) {
        switch (source[pos]) {
            0 => return error.ParseError,
            ' ', '\t', '\r', '\n' => continue,
            else => break,
        }
    }

    return pos;
}

fn eatToken(source: [:0]const u8, start: usize) !struct { usize, []const u8 } {
    var pos = start;
    pos = try seekWhitespace(source, pos);
    return .{ pos, source[start..pos] };
}

const ValueChange = struct {
    tag: Tag,
    value: []const u8,
    code: []const u8,

    pub const Tag = enum(u8) { scalar, vector };
};

// fn eatValueChange(source: [:0]const u8, start: usize) !ValueChange {
//     var pos = start;
//     switch (source[pos]) {
//         else => return error.UnexpectedCharacter,
//     }
// }

test "basic parsing" {
    const gpa = std.testing.allocator;

    const filename = "dummy.vcd";
    const max_bytes = 1024 * 1024;
    const source = try std.fs.cwd().readFileAllocOptions(
        gpa,
        filename,
        max_bytes,
        null,
        8,
        0,
    );
    defer gpa.free(source);

    const vcd = try parse(gpa, source);
    defer vcd.deinit(gpa);
}
